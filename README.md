# Urumi Store Provisioning Platform

This repo contains a small store provisioning platform for Round 1:

- React dashboard
- Node.js orchestrator API
- Helm chart that provisions a per-store WordPress + WooCommerce stack on Kubernetes

## 1. Prerequisites (all free)

On Windows (PowerShell as Administrator), install:

```powershell
choco install -y kubernetes-cli
choco install -y kind
choco install -y helm
choco install -y nodejs-lts
```

Then open a **new** PowerShell window.

## 2. Create local Kubernetes cluster (kind)

```powershell
kind create cluster --name urumi-stores
kubectl config use-context kind-urumi-stores
kubectl get nodes
```

## 3. Install nginx Ingress in the cluster

```powershell
kubectl create namespace ingress-nginx
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install ingress-nginx ingress-nginx/ingress-nginx `
  --namespace ingress-nginx `
  --set controller.publishService.enabled=true
```

## 4. Local domain (localtest.me) — no hosts file edits needed

This project uses `localtest.me` for local DNS (it resolves to 127.0.0.1 automatically). Example store URLs will be:

- `http://store-<id>.localtest.me`
- Dashboard stays at `http://localhost:5173`

You do NOT need to edit your `/etc/hosts` for local development when using the provided `values-local.yaml`.

## 5. Install project dependencies

From the repo root:

```powershell
cd "C:\Users\parth\Desktop\New folder (2)"
npm run backend:install
npm run dashboard:install
```

## 6. Run backend orchestrator

Starts the API on port 4000, talking to your kind cluster via `kubectl` config.

```powershell
cd "C:\Users\parth\Desktop\New folder (2)\backend"
npm run dev
```

You should see:

```text
Orchestrator listening on port 4000
```

## 7. Run React dashboard

In a **new** PowerShell window:

```powershell
cd "C:\Users\parth\Desktop\New folder (2)\dashboard"
$env:VITE_API_URL="http://localhost:4000"
npm run dev
```

Vite will print a URL like `http://localhost:5173`. Open it in your browser – this is the Node Dashboard.

## 8. End‑to‑end flow (local)

1. Go to the dashboard in the browser.
2. Click **Create Store**, keep engine `WooCommerce`.
3. Backend will:
   - Create a new row in SQLite.
   - Call `helm upgrade --install` on the `charts/store` Helm chart.
   - Create a new namespace, MySQL StatefulSet + PVC, WordPress Deployment, Service and Ingress.
4. Wait until status becomes **READY**.
5. Click **Open** – this goes to `http://store-<id>.localtest.me/`.
6. Complete initial WordPress setup, activate WooCommerce, add a demo product.
7. Place an order (e.g., Cash on Delivery) and confirm it appears in WooCommerce admin.
8. Back in the dashboard, click **Delete** to uninstall the Helm release and clean up.

## 9. Testing the Helm chart directly (local / prod)

From the chart directory you can install using pre-made values files. Do NOT set `host` manually — the chart derives the host from the release namespace + `ingress.baseDomain`.

Local (uses `localtest.me`):

```bash
cd charts/store
HELM_ENV=local helm upgrade --install demo-store . \
  --namespace store-demo \
  --create-namespace \
  -f values-local.yaml \
  --set storeId=demo \
  --set engine=woocommerce \
  --atomic \
  --timeout 10m
```

k3s / production example (uses `values-prod.yaml`):

```bash
HELM_ENV=prod helm upgrade --install demo-store . \
  --namespace store-demo \
  --create-namespace \
  -f values-prod.yaml \
  --set storeId=demo \
  --set engine=woocommerce \
  --atomic \
  --timeout 10m
```

Then open `http://store-demo.<baseDomain>/` (for local: `localtest.me`).

## 10. Notes

- No secrets are hard‑coded in code; DB credentials are generated by the backend and passed to Helm (stored in Kubernetes `Secret` named `db-credentials`).
- Namespace-per-store isolation: each provisioned store uses `store-<id>` namespace.
- Clean teardown: deletion uninstalls the Helm release, deletes the namespace (polled until gone) and only then removes the store row from SQLite—this prevents orphaned PVCs.
- Local DNS: `localtest.me` resolves to 127.0.0.1 (used by `values-local.yaml`).
- Use `HELM_ENV=local` or `HELM_ENV=prod` to select `values-*.yaml` when the backend or direct `helm` invocation installs the chart.
- Production (k3s) notes: use `values-prod.yaml` (storageClass configured for k3s), ensure ingress controller is present and baseDomain reachable.
- Persistent storage: MySQL PVC uses the configured `storageClass` and will survive pod restarts; restarting the MySQL pod should keep data intact.

